#!/usr/bin/env lua
--[[
  Copyright (C) 2020 LibreMesh.org
  This is free software, licensed under the GNU AFFERO GENERAL PUBLIC LICENSE Version 3

  Copyright 2020 Santiago Piccinini <spiccinini@altermindi.net>
]]--

local ubus = require "ubus"
local json = require 'luci.jsonc'
local utils = require 'lime.utils'
local config = require 'lime.config'
local upgrade = require 'lime.upgrade'
local iwinfo = require "iwinfo"

local conn = ubus.connect()
if not conn then
    error("Failed to connect to ubus")
end

local UPGRADE_METADATA_FILE = "/etc/upgrade_metadata"


local function set_root_password(msg)
    local result = nil
    if type(msg.password) ~= "string" then
        result = {status = 'error', msg = 'Password must be a string'}
    else
        utils.set_shared_root_password(msg.password or '')
        result = {status = 'ok'}
    end
    return utils.printJson(result)
end

local function set_hostname(msg)
    if msg.hostname ~= nil and utils.is_valid_hostname(msg.hostname) then
        local uci = config.get_uci_cursor()
        uci:set(config.UCI_NODE_NAME, 'system', 'hostname', msg.hostname)
        uci:commit(config.UCI_NODE_NAME)
        utils.unsafe_shell("lime-config && lime-apply")
        return utils.printJson({ status = 'ok'})
    else
        local err
        if msg.hostname then
            err = 'Invalid hostname'
        else
            err = 'Hostname not provided'
        end
        return utils.printJson({ status = 'error', msg = err })
    end
end

local function is_upgrade_confirm_supported()
    local supported = upgrade.is_upgrade_confirm_supported()
    return utils.printJson({status = 'ok', supported = supported})
end


local function firmware_upgrade(msg)
    local status, ret = upgrade.firmware_upgrade(msg.fw_path, msg.preserve_config, msg.metadata, msg.fw_type)
    if status then
        return utils.printJson({status = 'ok', metadata = ret})
    else
        return utils.printJson({status = 'error', message = ret})
    end
end

local function last_upgrade_metadata()
    local metadata
    if utils.file_exists(UPGRADE_METADATA_FILE) then
        metadata = utils.read_obj_store(UPGRADE_METADATA_FILE)
        return utils.printJson({status = 'ok', metadata = metadata})
    else
        return utils.printJson({status = 'error', message = 'No metadata available'})
    end
end

local function firmware_confirm()
    local exit_code = os.execute("safe-upgrade confirm > /dev/null 2>&1")
    local status = 'error'
    if exit_code == 0 then
        status = 'ok'
    end
    return utils.printJson({status = status, exit_code = exit_code})
end

--! Creates a client connection to a wifi hotspot
local function hotspot_wwan_enable(msg)
    local uci = config.get_uci_cursor()
    local encryption = msg.encryption or 'psk2'
    local ssid = msg.ssid or 'internet'
    local password = msg.password or 'internet'
    local radio = msg.radio or 'radio0'
    local iface_section_name = radio .. '_client_wwan'
    local network_name = 'client_wwan'
    uci:set('wireless', radio, 'disabled', '0')
    uci:set('wireless', iface_section_name, 'wifi-iface')
    uci:set('wireless', iface_section_name, 'device', radio)
    uci:set('wireless', iface_section_name, 'network', network_name)
    uci:set('wireless', iface_section_name, 'mode', 'sta')
    uci:set('wireless', iface_section_name, 'ifname', 'client-wwan')
    uci:set('wireless', iface_section_name, 'encryption', encryption)
    uci:set('wireless', iface_section_name, 'ssid', ssid)
    uci:set('wireless', iface_section_name, 'key', password)
    uci:commit('wireless')

    uci:set('network', network_name, 'interface')
    uci:set('network', network_name, 'proto', 'dhcp')
    uci:commit('network')
    utils.unsafe_shell("wifi reload")

    return utils.printJson({status = 'ok'})
end

local function hotspot_wwan_disable(msg)
    local uci = config.get_uci_cursor()
    local radio = msg.radio or 'radio0'
    local iface_section_name = radio .. '_client_wwan'

    uci:delete('wireless', iface_section_name)
    uci:commit('wireless')

    uci:delete('network', 'client_wwan')
    uci:commit('network')

    utils.unsafe_shell("wifi reload")
    return utils.printJson({status = 'ok'})
end

local function hotspot_wwan_get_status(msg)
    local msg = msg or {}
    local uci = config.get_uci_cursor()
    local radio = msg.radio or 'radio0'
    local connected = false
    local signal


    local iface_section_name = radio .. '_client_wwan'
    local enabled = false
    if uci:get('wireless', iface_section_name) then
        enabled = true
    end

    for mac, station in pairs(iwinfo.nl80211.assoclist('client-wwan')) do
        connected = true
        signal = station['signal']
    end

    return utils.printJson({status = 'ok', connected = connected, signal = signal, enabled = enabled})
end


local methods = {
    set_root_password = { password = 'value'},
    set_hostname = { hostname = 'value'},
    is_upgrade_confirm_supported = { no_params = 0 },
    firmware_upgrade = { fw_path = 'value', preserve_config = 'value', metadata = 'value', fw_type = 'value'},
    last_upgrade_metadata = { no_params = 0 },
    firmware_confirm = { no_params = 0 },
    hotspot_wwan_enable = { radio = 'value', ssid = 'value', password = 'value', encryption = 'value'},
    hotspot_wwan_disable = { radio = 'value' },
    hotspot_wwan_get_status = { no_params = 0 }
}

if arg[1] == 'list' then
    utils.printJson(methods)
end

if arg[1] == 'call' then
    local msg = utils.rpcd_readline()
    msg = json.parse(msg)
    if      arg[2] == 'set_root_password' then set_root_password(msg)
    elseif  arg[2] == 'set_hostname' then set_hostname(msg)
    elseif  arg[2] == 'is_upgrade_confirm_supported' then is_upgrade_confirm_supported(msg)
    elseif  arg[2] == 'firmware_upgrade' then firmware_upgrade(msg)
    elseif  arg[2] == 'last_upgrade_metadata' then last_upgrade_metadata(msg)
    elseif  arg[2] == 'firmware_confirm' then firmware_confirm(msg)
    elseif  arg[2] == 'hotspot_wwan_enable' then hotspot_wwan_enable(msg)
    elseif  arg[2] == 'hotspot_wwan_disable' then hotspot_wwan_disable(msg)
    elseif  arg[2] == 'hotspot_wwan_get_status' then hotspot_wwan_get_status(msg)
    else utils.printJson({ error = "Method not found" })
    end
end
